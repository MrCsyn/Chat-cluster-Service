# 项目数据库设计

数据库设计上有5个表，分别是uer表、friend表、allgroup表、groupuser表、offlinemessage表，下面分别介绍其作用与设计的字段

## user表

user表是用来存储用户注册信息的，字段包含有

+ id,采用定长字符串，也是表的主键，是用户注册的唯一标识
+ name用户名，允许修改
+ password用户密码，从安全考虑，存储为md5值
+ state表示当前用户是在线online还是离线offline，有且只有两种状态

## friend表

friend表是用来关联用户还有信息的，字段有

+ userid，当前用户名
+ friendid，好友用户名
+ id采用自增id，主键

## allgroup表

表示当前系统存储有哪些群聊，字段有

+ id，群号，是主键，唯一标识
+ groupname，群名，允许重复
+ groupdesc，群描述

## groupuser表

存储群聊成员信息，字段有

+ id，自增id，主键
+ groupid，群号
+ userid，群成员id号
+ grouprole，当前群成员的角色，比如群主、群管理员或者普通成员

## offlinemessage表

离线信息表，用来存储利息按信息的，字段有

+ id，自增id，设置为主键
+ userid，用户id，允许重复
+ message，具体的离线信息

# mysql数据库代码封装

对数据库常规的连接、更新、查询和释放资源进行设计模式上的封装，提高代码的复用性

~~~cpp
// 数据库操作类
class MySQL
{
public:
    // 初始化数据库连接
    MySQL();
    // 释放数据库连接资源
    ~MySQL();
    // 连接数据库
    bool connect();
    // 更新操作
    bool update(string sql);
    // 查询操作
    MYSQL_RES *query(string sql);
    // 获取连接
    MYSQL* getConnection();
private:
    MYSQL *_conn;
};
~~~

# 离线信息模块的封装

具体的可以根据数据库的设计，将离线信息插入对应的数据库当中，由于具体的代码实现比较冗杂，这里只展现接口

~~~cpp
// 提供离线消息表的操作接口方法
class OfflineMsgModel
{
public:
    // 存储用户的离线消息
    void insert(int userid, string msg);

    // 删除用户的离线消息
    void remove(int userid);

    // 查询用户的离线消息
    vector<string> query(int userid);
};
~~~



# 业务上逻辑代码的实现

下面是业务注册、登录、点对点发送消息、客户端异常退出等业务层代码上的设计

## 注册业务的实现

先进行函数回调的绑定，再基于json信息将相关数据插入数据库中，插入成功则注册成功，反之注册失败

~~~cpp
//首先是基于muduo库进行函数绑定，触发该事件进行函数回调
_msgHandlerMap.insert({REG_MSG, std::bind(&ChatService::reg, this, _1, _2, _3)});

// 处理注册业务  name  password
void ChatService::reg(const TcpConnectionPtr &conn, json &js, Timestamp time)
{
    string name = js["name"];
    string pwd = js["password"];

    User user;
    user.setName(name);
    user.setPwd(pwd);
    bool state = _userModel.insert(user);
    if (state)
    {
        // 注册成功
        json response;
        response["msgid"] = REG_MSG_ACK;
        response["errno"] = 0;
        response["id"] = user.getId();
        conn->send(response.dump());
    }
    else
    {
        // 注册失败
        json response;
        response["msgid"] = REG_MSG_ACK;
        response["errno"] = 1;
        conn->send(response.dump());
    }
}
~~~

## 登录业务的实现

首先先进行函数绑定，根据json信息查询数据库中是否存在该用户，并且验证密码，验证成功则将该id跟链接插入到当前服务器的一个哈希键值对表中，给用户返回相应的respone，给用户返回好友列表，群组列表、群成员以及离线信息

~~~cpp
//先进行函数绑定
_msgHandlerMap.insert({LOGIN_MSG, std::bind(&ChatService::login, this, _1, _2, _3)});

// 处理登录业务  id  pwd   pwd
void ChatService::login(const TcpConnectionPtr &conn, json &js, Timestamp time)
{
    int id = js["id"].get<int>();
    string pwd = js["password"];

    User user = _userModel.query(id);
    if (user.getId() == id && user.getPwd() == pwd)
    {
        if (user.getState() == "online")
        {
            // 该用户已经登录，不允许重复登录
            json response;
            response["msgid"] = LOGIN_MSG_ACK;
            response["errno"] = 2;
            response["errmsg"] = "this account is using, input another!";
            conn->send(response.dump());
        }
        else
        {
            // 登录成功，记录用户连接信息
            {
                lock_guard<mutex> lock(_connMutex);
                _userConnMap.insert({id, conn});
            }

            // id用户登录成功后，向redis订阅channel(id)
            _redis.subscribe(id); 

            // 登录成功，更新用户状态信息 state offline=>online
            user.setState("online");
            _userModel.updateState(user);

            json response;
            response["msgid"] = LOGIN_MSG_ACK;
            response["errno"] = 0;
            response["id"] = user.getId();
            response["name"] = user.getName();
            // 查询该用户是否有离线消息
            vector<string> vec = _offlineMsgModel.query(id);
            if (!vec.empty())
            {
                response["offlinemsg"] = vec;
                // 读取该用户的离线消息后，把该用户的所有离线消息删除掉
                _offlineMsgModel.remove(id);
            }

            // 查询该用户的好友信息并返回
            vector<User> userVec = _friendModel.query(id);
            if (!userVec.empty())
            {
                vector<string> vec2;
                for (User &user : userVec)
                {
                    json js;
                    js["id"] = user.getId();
                    js["name"] = user.getName();
                    js["state"] = user.getState();
                    vec2.push_back(js.dump());
                }
                response["friends"] = vec2;
            }

            // 查询用户的群组信息
            vector<Group> groupuserVec = _groupModel.queryGroups(id);
            if (!groupuserVec.empty())
            {
                // group:[{groupid:[xxx, xxx, xxx, xxx]}]
                vector<string> groupV;
                for (Group &group : groupuserVec)
                {
                    json grpjson;
                    grpjson["id"] = group.getId();
                    grpjson["groupname"] = group.getName();
                    grpjson["groupdesc"] = group.getDesc();
                    vector<string> userV;
                    for (GroupUser &user : group.getUsers())
                    {
                        json js;
                        js["id"] = user.getId();
                        js["name"] = user.getName();
                        js["state"] = user.getState();
                        js["role"] = user.getRole();
                        userV.push_back(js.dump());
                    }
                    grpjson["users"] = userV;
                    groupV.push_back(grpjson.dump());
                }

                response["groups"] = groupV;
            }

            conn->send(response.dump());
        }
    }
    else
    {
        // 该用户不存在，用户存在但是密码错误，登录失败
        json response;
        response["msgid"] = LOGIN_MSG_ACK;
        response["errno"] = 1;
        response["errmsg"] = "id or password is invalid!";
        conn->send(response.dump());
    }
}
~~~

## 客户端异常退出

注册回调函数，客户端异常退出，释放对应的链接资源和哈希对中的信息,取消该用户的消息订阅，将该用户的状态改为offline

~~~cpp
_msgHandlerMap.insert({LOGINOUT_MSG, std::bind(&ChatService::loginout, this, _1, _2, _3)});

// 处理客户端异常退出
void ChatService::clientCloseException(const TcpConnectionPtr &conn)
{
    User user;
    {
        lock_guard<mutex> lock(_connMutex);
        for (auto it = _userConnMap.begin(); it != _userConnMap.end(); ++it)
        {
            if (it->second == conn)
            {
                // 从map表删除用户的链接信息
                user.setId(it->first);
                _userConnMap.erase(it);
                break;
            }
        }
    }

    // 用户注销，相当于就是下线，在redis中取消订阅通道
    _redis.unsubscribe(user.getId()); 

    // 更新用户的状态信息
    if (user.getId() != -1)
    {
        user.setState("offline");
        _userModel.updateState(user);
    }
}
~~~

## 点对点聊天服务

先跟据该用户要发送信息的对象id，查询接收方是否在线，若在线则服务器主动推送信息，如果不在线，则存储离线信息，等待下回该用户上线，将离线信息推送给用户。此外，如果是跨服务器，则需要根据消息队列，本项目中采用redis的发布订阅模式实现集群通信

~~~cpp
// 一对一聊天业务
void ChatService::oneChat(const TcpConnectionPtr &conn, json &js, Timestamp time)
{
    int toid = js["toid"].get<int>();

    {
        lock_guard<mutex> lock(_connMutex);
        auto it = _userConnMap.find(toid);
        if (it != _userConnMap.end())
        {
            // toid在线，转发消息   服务器主动推送消息给toid用户
            it->second->send(js.dump());
            return;
        }
    }

    // 查询toid是否在线 
    User user = _userModel.query(toid);
    if (user.getState() == "online")
    {
        _redis.publish(toid, js.dump());
        return;
    }

    // toid不在线，存储离线消息
    _offlineMsgModel.insert(toid, js.dump());
}
~~~

## 添加好友业务

获取用户id跟要添加的还有id，查询id是否存在，如存在则在表中添加该记录

~~~cpp
// 添加好友业务 msgid id friendid
void ChatService::addFriend(const TcpConnectionPtr &conn, json &js, Timestamp time)
{
    int userid = js["id"].get<int>();
    int friendid = js["friendid"].get<int>();

    // 存储好友信息
    _friendModel.insert(userid, friendid);
}
~~~

## 创建群组业务

~~~cpp
// 创建群组业务
void ChatService::createGroup(const TcpConnectionPtr &conn, json &js, Timestamp time)
{
    int userid = js["id"].get<int>();
    string name = js["groupname"];
    string desc = js["groupdesc"];

    // 存储新创建的群组信息
    Group group(-1, name, desc);
    if (_groupModel.createGroup(group))
    {
        // 存储群组创建人信息
        _groupModel.addGroup(userid, group.getId(), "creator");
    }
}
~~~

## 添加群组业务

~~~cpp
// 加入群组业务
void ChatService::addGroup(const TcpConnectionPtr &conn, json &js, Timestamp time)
{
    int userid = js["id"].get<int>();
    int groupid = js["groupid"].get<int>();
    _groupModel.addGroup(userid, groupid, "normal");
}
~~~

## 群聊天业务

根据群id获取群成员，然后向所有群成员发送该消息,当然这里也有离线消息处理

~~~cpp
// 群组聊天业务
void ChatService::groupChat(const TcpConnectionPtr &conn, json &js, Timestamp time)
{
    int userid = js["id"].get<int>();
    int groupid = js["groupid"].get<int>();
    vector<int> useridVec = _groupModel.queryGroupUsers(userid, groupid);

    lock_guard<mutex> lock(_connMutex);
    for (int id : useridVec)
    {
        auto it = _userConnMap.find(id);
        if (it != _userConnMap.end())
        {
            // 转发群消息
            it->second->send(js.dump());
        }
        else
        {
            // 查询toid是否在线 
            User user = _userModel.query(id);
            if (user.getState() == "online")
            {
                _redis.publish(id, js.dump());
            }
            else
            {
                // 存储离线群消息
                _offlineMsgModel.insert(id, js.dump());
            }
        }
    }
}
~~~

# 集群实现方式

## nginx实现负载均衡

为提高服务器的高并发处理能力，引入集群分布式，多台主机合作处理业务，本人项目中根据服务器性能进行权重配置，大致情况如下图。但引入集群会带来服务器集群的通信问题，后面解释消息队列

![负载均衡1](https://gitee.com/csyn9527/blogpicture/raw/master/imag/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A11.png)

## redis消息队列实现跨服务器的集群通信

有这么一种业务场景，用户a登录，链接在A服务器，用户b登录，链接在B服务器上，a要给b发送信息。实现方案如下

1. b登录时，B服务器会订阅b的信息
2. A服务器先在当前服务器上查找是否有b的链接，如果没有
3. 访问数据库，查看b的登录状态，如果登录是online
4. 将信息通过redis的发布-订阅模式发布到b的频道
5. 服务器B订阅b频道，处理信息

~~~cpp
// 从redis消息队列中获取订阅的消息
void ChatService::handleRedisSubscribeMessage(int userid, string msg)
{
    lock_guard<mutex> lock(_connMutex);
    auto it = _userConnMap.find(userid);
    if (it != _userConnMap.end())
    {
        it->second->send(msg);
        return;
    }

    // 存储该用户的离线消息
    _offlineMsgModel.insert(userid, msg);
}
~~~



